-- Enable the pgvector extension to work with embedding vectors
CREATE EXTENSION IF NOT EXISTS vector;

-- Create a table to store manual embeddings
CREATE TABLE IF NOT EXISTS public.manual_embeddings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  manual_id UUID REFERENCES public.technical_manuals(id) ON DELETE CASCADE,
  content TEXT, -- The text chunk
  embedding vector(1536), -- OpenAI embedding size (small-3). use 768 for Gemini text-embedding-004 if needed, but 1536 is standard for compatibility
  metadata JSONB, -- storing page number, etc
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Enable RLS on the new table
ALTER TABLE public.manual_embeddings ENABLE ROW LEVEL SECURITY;

-- Allow read access to authenticated users
CREATE POLICY "Allow read access to authenticated users"
ON public.manual_embeddings
FOR SELECT
TO authenticated
USING (true);

-- Allow insert/update/delete to authenticated users (admin logic handled in app for now, or refine later)
CREATE POLICY "Allow write access to authenticated users"
ON public.manual_embeddings
FOR ALL
TO authenticated
USING (true)
WITH CHECK (true);

-- Create a function to search for manuals
create or replace function match_manuals (
  query_embedding vector(1536),
  match_threshold float,
  match_count int
)
returns table (
  id bigint,
  manual_id uuid,
  content text,
  similarity float
)
language plpgsql
as $$
begin
  return query
  select
    manual_embeddings.id,
    manual_embeddings.manual_id,
    manual_embeddings.content,
    1 - (manual_embeddings.embedding <=> query_embedding) as similarity
  from manual_embeddings
  where 1 - (manual_embeddings.embedding <=> query_embedding) > match_threshold
  order by manual_embeddings.embedding <=> query_embedding
  limit match_count;
end;
$$;
